{"ast":null,"code":"'use client';\n\nimport { ariaAttr, callAllHandlers, dataAttr } from \"./chunk-DX64QB22.mjs\";\nimport { getIsReversed, getStyles } from \"./chunk-E23N4XEN.mjs\";\n\n// src/use-slider.ts\nimport { usePanEvent } from \"@chakra-ui/react-use-pan-event\";\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { useSize } from \"@chakra-ui/react-use-size\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { useLatestRef } from \"@chakra-ui/react-use-latest-ref\";\nimport { clampValue, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/number-utils\";\nimport { useCallback, useMemo, useRef, useId, useState } from \"react\";\nfunction useSlider(props) {\n  var _a;\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props;\n  const onChangeStart = useCallbackRef(onChangeStartProp);\n  const onChangeEnd = useCallbackRef(onChangeEndProp);\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange\n  });\n  const [isDragging, setDragging] = useState(false);\n  const [isFocused, setFocused] = useState(false);\n  const isInteractive = !(isDisabled || isReadOnly);\n  const tenSteps = (max - min) / 10;\n  const oneStep = step || (max - min) / 100;\n  const value = clampValue(computedValue, min, max);\n  const reversedValue = max - value + min;\n  const trackValue = isReversed ? reversedValue : value;\n  const thumbPercent = valueToPercent(trackValue, min, max);\n  const isVertical = orientation === \"vertical\";\n  const stateRef = useLatestRef({\n    min,\n    max,\n    step,\n    isDisabled,\n    value,\n    isInteractive,\n    isReversed,\n    isVertical,\n    eventSource: null,\n    focusThumbOnChange,\n    orientation\n  });\n  const trackRef = useRef(null);\n  const thumbRef = useRef(null);\n  const rootRef = useRef(null);\n  const reactId = useId();\n  const uuid = idProp != null ? idProp : reactId;\n  const [thumbId, trackId] = [`slider-thumb-${uuid}`, `slider-track-${uuid}`];\n  const getValueFromPointer = useCallback(event => {\n    var _a2, _b;\n    if (!trackRef.current) return;\n    const state2 = stateRef.current;\n    state2.eventSource = \"pointer\";\n    const trackRect = trackRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = (_b = (_a2 = event.touches) == null ? void 0 : _a2[0]) != null ? _b : event;\n    const diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    const length = isVertical ? trackRect.height : trackRect.width;\n    let percent = diff / length;\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n    let nextValue = percentToValue(percent, state2.min, state2.max);\n    if (state2.step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, state2.min, state2.step));\n    }\n    nextValue = clampValue(nextValue, state2.min, state2.max);\n    return nextValue;\n  }, [isVertical, isReversed, stateRef]);\n  const constrain = useCallback(value2 => {\n    const state2 = stateRef.current;\n    if (!state2.isInteractive) return;\n    value2 = parseFloat(roundValueToStep(value2, state2.min, oneStep));\n    value2 = clampValue(value2, state2.min, state2.max);\n    setValue(value2);\n  }, [oneStep, setValue, stateRef]);\n  const actions = useMemo(() => ({\n    stepUp(step2 = oneStep) {\n      const next = isReversed ? value - step2 : value + step2;\n      constrain(next);\n    },\n    stepDown(step2 = oneStep) {\n      const next = isReversed ? value + step2 : value - step2;\n      constrain(next);\n    },\n    reset() {\n      constrain(defaultValue || 0);\n    },\n    stepTo(value2) {\n      constrain(value2);\n    }\n  }), [constrain, isReversed, value, oneStep, defaultValue]);\n  const onKeyDown = useCallback(event => {\n    const state2 = stateRef.current;\n    const keyMap = {\n      ArrowRight: () => actions.stepUp(),\n      ArrowUp: () => actions.stepUp(),\n      ArrowLeft: () => actions.stepDown(),\n      ArrowDown: () => actions.stepDown(),\n      PageUp: () => actions.stepUp(tenSteps),\n      PageDown: () => actions.stepDown(tenSteps),\n      Home: () => constrain(state2.min),\n      End: () => constrain(state2.max)\n    };\n    const action = keyMap[event.key];\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      state2.eventSource = \"keyboard\";\n    }\n  }, [actions, constrain, tenSteps, stateRef]);\n  const valueText = (_a = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _a : ariaValueText;\n  const thumbSize = useSize(thumbRef);\n  const {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => {\n    const state2 = stateRef.current;\n    const thumbRect = thumbSize != null ? thumbSize : {\n      width: 0,\n      height: 0\n    };\n    return getStyles({\n      isReversed,\n      orientation: state2.orientation,\n      thumbRects: [thumbRect],\n      thumbPercents: [thumbPercent]\n    });\n  }, [isReversed, thumbSize, thumbPercent, stateRef]);\n  const focusThumb = useCallback(() => {\n    const state2 = stateRef.current;\n    if (state2.focusThumbOnChange) {\n      setTimeout(() => {\n        var _a2;\n        return (_a2 = thumbRef.current) == null ? void 0 : _a2.focus();\n      });\n    }\n  }, [stateRef]);\n  useUpdateEffect(() => {\n    const state2 = stateRef.current;\n    focusThumb();\n    if (state2.eventSource === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(state2.value);\n    }\n  }, [value, onChangeEnd]);\n  function setValueFromPointer(event) {\n    const nextValue = getValueFromPointer(event);\n    if (nextValue != null && nextValue !== stateRef.current.value) {\n      setValue(nextValue);\n    }\n  }\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      const state2 = stateRef.current;\n      if (!state2.isInteractive) return;\n      setDragging(true);\n      focusThumb();\n      setValueFromPointer(event);\n      onChangeStart == null ? void 0 : onChangeStart(state2.value);\n    },\n    onPanSessionEnd() {\n      const state2 = stateRef.current;\n      if (!state2.isInteractive) return;\n      setDragging(false);\n      onChangeEnd == null ? void 0 : onChangeEnd(state2.value);\n    },\n    onPan(event) {\n      const state2 = stateRef.current;\n      if (!state2.isInteractive) return;\n      setValueFromPointer(event);\n    }\n  });\n  const getRootProps = useCallback((props2 = {}, ref = null) => {\n    return {\n      ...props2,\n      ...htmlProps,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: {\n        ...props2.style,\n        ...rootStyle\n      }\n    };\n  }, [htmlProps, isDisabled, isFocused, rootStyle]);\n  const getTrackProps = useCallback((props2 = {}, ref = null) => {\n    return {\n      ...props2,\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: {\n        ...props2.style,\n        ...trackStyle\n      }\n    };\n  }, [isDisabled, trackId, trackStyle]);\n  const getInnerTrackProps = useCallback((props2 = {}, ref = null) => {\n    return {\n      ...props2,\n      ref,\n      style: {\n        ...props2.style,\n        ...innerTrackStyle\n      }\n    };\n  }, [innerTrackStyle]);\n  const getThumbProps = useCallback((props2 = {}, ref = null) => {\n    return {\n      ...props2,\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : void 0,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? void 0 : ariaLabelledBy,\n      style: {\n        ...props2.style,\n        ...getThumbStyle(0)\n      },\n      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props2.onFocus, () => setFocused(true)),\n      onBlur: callAllHandlers(props2.onBlur, () => setFocused(false))\n    };\n  }, [isInteractive, thumbId, isDragging, valueText, min, max, value, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown]);\n  const getMarkerProps = useCallback((props2, ref = null) => {\n    const isInRange = !(props2.value < min || props2.value > max);\n    const isHighlighted = value >= props2.value;\n    const markerPercent = valueToPercent(props2.value, min, max);\n    const markerStyle = {\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      ...orient({\n        orientation,\n        vertical: {\n          bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`\n        },\n        horizontal: {\n          left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`\n        }\n      })\n    };\n    return {\n      ...props2,\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: {\n        ...props2.style,\n        ...markerStyle\n      }\n    };\n  }, [isDisabled, isReversed, max, min, orientation, value]);\n  const getInputProps = useCallback((props2 = {}, ref = null) => {\n    return {\n      ...props2,\n      ref,\n      type: \"hidden\",\n      value,\n      name\n    };\n  }, [name, value]);\n  const state = {\n    value,\n    isFocused,\n    isDragging\n  };\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps\n  };\n}\nfunction orient(options) {\n  const {\n    orientation,\n    vertical,\n    horizontal\n  } = options;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}\nexport { useSlider };","map":{"version":3,"names":["usePanEvent","useCallbackRef","useUpdateEffect","useControllableState","useSize","mergeRefs","useLatestRef","clampValue","percentToValue","roundValueToStep","valueToPercent","useCallback","useMemo","useRef","useId","useState","useSlider","props","_a","min","max","onChange","value","valueProp","defaultValue","isReversed","isReversedProp","direction","orientation","id","idProp","isDisabled","isReadOnly","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","step","getAriaValueText","getAriaValueTextProp","ariaValueText","ariaLabel","ariaLabelledBy","name","focusThumbOnChange","htmlProps","getIsReversed","computedValue","setValue","getDefaultValue","isDragging","setDragging","isFocused","setFocused","isInteractive","tenSteps","oneStep","reversedValue","trackValue","thumbPercent","isVertical","stateRef","eventSource","trackRef","thumbRef","rootRef","reactId","uuid","thumbId","trackId","getValueFromPointer","event","_a2","_b","current","state2","trackRect","getBoundingClientRect","clientX","clientY","touches","diff","bottom","left","length","height","width","percent","nextValue","parseFloat","constrain","value2","actions","stepUp","step2","next","stepDown","reset","stepTo","onKeyDown","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","key","preventDefault","stopPropagation","valueText","thumbSize","getThumbStyle","rootStyle","trackStyle","innerTrackStyle","thumbRect","getStyles","thumbRects","thumbPercents","focusThumb","setTimeout","focus","setValueFromPointer","onPanSessionStart","onPanSessionEnd","onPan","getRootProps","props2","ref","tabIndex","ariaAttr","dataAttr","style","getTrackProps","getInnerTrackProps","getThumbProps","role","callAllHandlers","onFocus","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","position","pointerEvents","orient","vertical","horizontal","getInputProps","type","state","options"],"sources":["C:\\Users\\ASUS\\OneDrive\\Documents\\Unit6_Cw\\eCommercebenevolent-boot\\musemind\\node_modules\\@chakra-ui\\slider\\src\\use-slider.ts"],"sourcesContent":["import { usePanEvent } from \"@chakra-ui/react-use-pan-event\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useSize } from \"@chakra-ui/react-use-size\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { useLatestRef } from \"@chakra-ui/react-use-latest-ref\"\nimport type { PropGetter, RequiredPropGetter } from \"@chakra-ui/react-types\"\nimport {\n  clampValue,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/number-utils\"\nimport { ariaAttr, callAllHandlers, dataAttr } from \"@chakra-ui/utils\"\nimport { useCallback, useMemo, useRef, useId, useState } from \"react\"\nimport { getIsReversed, getStyles } from \"./slider-utils\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * Orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   * @default false\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n  /**\n   * The writing mode\n   * @default \"ltr\"\n   */\n  direction?: \"ltr\" | \"rtl\"\n}\n\nexport interface SliderState {\n  value: number\n  isFocused: boolean\n  isDragging: boolean\n}\n\nexport interface SliderActions {\n  stepUp(step?: number): void\n  stepDown(step?: number): void\n  reset(): void\n  stepTo(value: number): void\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/slider/\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  const [isDragging, setDragging] = useState(false)\n  const [isFocused, setFocused] = useState(false)\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const thumbPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  const stateRef = useLatestRef({\n    min,\n    max,\n    step,\n    isDisabled,\n    value,\n    isInteractive,\n    isReversed,\n    isVertical,\n    eventSource: null as \"pointer\" | \"keyboard\" | null,\n    focusThumbOnChange,\n    orientation,\n  })\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<HTMLElement>(null)\n  const thumbRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const reactId = useId()\n  const uuid = idProp ?? reactId\n  const [thumbId, trackId] = [`slider-thumb-${uuid}`, `slider-track-${uuid}`]\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  const getValueFromPointer = useCallback(\n    (event: any) => {\n      if (!trackRef.current) return\n\n      const state = stateRef.current\n      state.eventSource = \"pointer\"\n\n      const trackRect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, state.min, state.max)\n\n      if (state.step) {\n        nextValue = parseFloat(\n          roundValueToStep(nextValue, state.min, state.step),\n        )\n      }\n\n      nextValue = clampValue(nextValue, state.min, state.max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, stateRef],\n  )\n\n  const constrain = useCallback(\n    (value: number) => {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      value = parseFloat(roundValueToStep(value, state.min, oneStep))\n      value = clampValue(value, state.min, state.max)\n      setValue(value)\n    },\n    [oneStep, setValue, stateRef],\n  )\n\n  const actions: SliderActions = useMemo(\n    () => ({\n      stepUp(step = oneStep) {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown(step = oneStep) {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset() {\n        constrain(defaultValue || 0)\n      },\n      stepTo(value: number) {\n        constrain(value)\n      },\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const state = stateRef.current\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(state.min),\n        End: () => constrain(state.max),\n      }\n\n      const action = keyMap[event.key]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        state.eventSource = \"keyboard\"\n      }\n    },\n    [actions, constrain, tenSteps, stateRef],\n  )\n\n  /**\n   * ARIA (Optional): To define a human-readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb, so\n   * we can center it within the track properly\n   */\n  const thumbSize = useSize(thumbRef)\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } =\n    useMemo(() => {\n      const state = stateRef.current\n\n      const thumbRect = thumbSize ?? { width: 0, height: 0 }\n      return getStyles({\n        isReversed,\n        orientation: state.orientation,\n        thumbRects: [thumbRect],\n        thumbPercents: [thumbPercent],\n      })\n    }, [isReversed, thumbSize, thumbPercent, stateRef])\n\n  const focusThumb = useCallback(() => {\n    const state = stateRef.current\n    if (state.focusThumbOnChange) {\n      setTimeout(() => thumbRef.current?.focus())\n    }\n  }, [stateRef])\n\n  useUpdateEffect(() => {\n    const state = stateRef.current\n    focusThumb()\n    if (state.eventSource === \"keyboard\") {\n      onChangeEnd?.(state.value)\n    }\n  }, [value, onChangeEnd])\n\n  function setValueFromPointer(event: MouseEvent | TouchEvent | PointerEvent) {\n    const nextValue = getValueFromPointer(event)\n    if (nextValue != null && nextValue !== stateRef.current.value) {\n      setValue(nextValue)\n    }\n  }\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      setDragging(true)\n      focusThumb()\n      setValueFromPointer(event)\n      onChangeStart?.(state.value)\n    },\n    onPanSessionEnd() {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      setDragging(false)\n      onChangeEnd?.(state.value)\n    },\n    onPan(event) {\n      const state = stateRef.current\n      if (!state.isInteractive) return\n      setValueFromPointer(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ...htmlProps,\n        ref: mergeRefs(ref, rootRef),\n        tabIndex: -1,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"data-focused\": dataAttr(isFocused),\n        style: {\n          ...props.style,\n          ...rootStyle,\n        },\n      }\n    },\n    [htmlProps, isDisabled, isFocused, rootStyle],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, trackRef),\n        id: trackId,\n        \"data-disabled\": dataAttr(isDisabled),\n        style: {\n          ...props.style,\n          ...trackStyle,\n        },\n      }\n    },\n    [isDisabled, trackId, trackStyle],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        style: {\n          ...props.style,\n          ...innerTrackStyle,\n        },\n      }\n    },\n    [innerTrackStyle],\n  )\n\n  const getThumbProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, thumbRef),\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: thumbId,\n        \"data-active\": dataAttr(isDragging),\n        \"aria-valuetext\": valueText,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": value,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n        style: {\n          ...props.style,\n          ...getThumbStyle(0),\n        },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => setFocused(true)),\n        onBlur: callAllHandlers(props.onBlur, () => setFocused(false)),\n      }\n    },\n    [\n      isInteractive,\n      thumbId,\n      isDragging,\n      valueText,\n      min,\n      max,\n      value,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n    ],\n  )\n\n  const getMarkerProps: RequiredPropGetter<{ value: number }> = useCallback(\n    (props, ref = null) => {\n      const isInRange = !(props.value < min || props.value > max)\n      const isHighlighted = value >= props.value\n      const markerPercent = valueToPercent(props.value, min, max)\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation: orientation,\n          vertical: {\n            bottom: isReversed\n              ? `${100 - markerPercent}%`\n              : `${markerPercent}%`,\n          },\n          horizontal: {\n            left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n          },\n        }),\n      }\n\n      return {\n        ...props,\n        ref,\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value],\n  )\n\n  const getInputProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        type: \"hidden\",\n        value,\n        name,\n      }\n    },\n    [name, value],\n  )\n\n  const state: SliderState = { value, isFocused, isDragging }\n\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: React.CSSProperties\n  horizontal: React.CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}