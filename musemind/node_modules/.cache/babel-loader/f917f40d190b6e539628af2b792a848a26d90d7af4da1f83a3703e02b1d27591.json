{"ast":null,"code":"'use client';\n\nimport { useShortcut } from \"./chunk-YSKACL7R.mjs\";\nimport { getNextItemFromSearch } from \"./chunk-BWUXSGSJ.mjs\";\n\n// src/use-menu.ts\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { useFocusOnHide } from \"@chakra-ui/react-use-focus-effect\";\nimport { usePopper } from \"@chakra-ui/popper\";\nimport { useDisclosure } from \"@chakra-ui/react-use-disclosure\";\nimport { useOutsideClick } from \"@chakra-ui/react-use-outside-click\";\nimport { useAnimationState } from \"@chakra-ui/react-use-animation-state\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { dataAttr, callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { cloneElement, useCallback, useRef, useState, useId, useMemo, useEffect } from \"react\";\nvar [MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant] = createDescendantContext();\nvar [MenuProvider, useMenuContext] = createContext({\n  strict: false,\n  name: \"MenuContext\"\n});\nfunction useIds(idProp, ...prefixes) {\n  const reactId = useId();\n  const id = idProp || reactId;\n  return useMemo(() => {\n    return prefixes.map(prefix => `${prefix}-${id}`);\n  }, [id, prefixes]);\n}\nfunction getOwnerDocument(node) {\n  var _a;\n  return (_a = node == null ? void 0 : node.ownerDocument) != null ? _a : document;\n}\nfunction isActiveElement(element) {\n  const doc = getOwnerDocument(element);\n  return doc.activeElement === element;\n}\nfunction useMenu(props = {}) {\n  const {\n    id,\n    closeOnSelect = true,\n    closeOnBlur = true,\n    initialFocusRef,\n    autoSelect = true,\n    isLazy,\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    placement = \"bottom-start\",\n    lazyBehavior = \"unmount\",\n    direction,\n    computePositionOnMount = false,\n    ...popperProps\n  } = props;\n  const menuRef = useRef(null);\n  const buttonRef = useRef(null);\n  const descendants = useMenuDescendants();\n  const focusMenu = useCallback(() => {\n    requestAnimationFrame(() => {\n      var _a;\n      (_a = menuRef.current) == null ? void 0 : _a.focus({\n        preventScroll: false\n      });\n    });\n  }, []);\n  const focusFirstItem = useCallback(() => {\n    const id2 = setTimeout(() => {\n      var _a;\n      if (initialFocusRef) {\n        (_a = initialFocusRef.current) == null ? void 0 : _a.focus();\n      } else {\n        const first = descendants.firstEnabled();\n        if (first) setFocusedIndex(first.index);\n      }\n    });\n    timeoutIds.current.add(id2);\n  }, [descendants, initialFocusRef]);\n  const focusLastItem = useCallback(() => {\n    const id2 = setTimeout(() => {\n      const last = descendants.lastEnabled();\n      if (last) setFocusedIndex(last.index);\n    });\n    timeoutIds.current.add(id2);\n  }, [descendants]);\n  const onOpenInternal = useCallback(() => {\n    onOpenProp == null ? void 0 : onOpenProp();\n    if (autoSelect) {\n      focusFirstItem();\n    } else {\n      focusMenu();\n    }\n  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);\n  const {\n    isOpen,\n    onOpen,\n    onClose,\n    onToggle\n  } = useDisclosure({\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenInternal\n  });\n  useOutsideClick({\n    enabled: isOpen && closeOnBlur,\n    ref: menuRef,\n    handler: event => {\n      var _a;\n      if (!((_a = buttonRef.current) == null ? void 0 : _a.contains(event.target))) {\n        onClose();\n      }\n    }\n  });\n  const popper = usePopper({\n    ...popperProps,\n    enabled: isOpen || computePositionOnMount,\n    placement,\n    direction\n  });\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  useUpdateEffect(() => {\n    if (!isOpen) {\n      setFocusedIndex(-1);\n    }\n  }, [isOpen]);\n  useFocusOnHide(menuRef, {\n    focusRef: buttonRef,\n    visible: isOpen,\n    shouldFocus: true\n  });\n  const animationState = useAnimationState({\n    isOpen,\n    ref: menuRef\n  });\n  const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`);\n  const openAndFocusMenu = useCallback(() => {\n    onOpen();\n    focusMenu();\n  }, [onOpen, focusMenu]);\n  const timeoutIds = useRef( /* @__PURE__ */new Set([]));\n  useEffect(() => {\n    const ids = timeoutIds.current;\n    return () => {\n      ids.forEach(id2 => clearTimeout(id2));\n      ids.clear();\n    };\n  }, []);\n  const openAndFocusFirstItem = useCallback(() => {\n    onOpen();\n    focusFirstItem();\n  }, [focusFirstItem, onOpen]);\n  const openAndFocusLastItem = useCallback(() => {\n    onOpen();\n    focusLastItem();\n  }, [onOpen, focusLastItem]);\n  const refocus = useCallback(() => {\n    var _a, _b;\n    const doc = getOwnerDocument(menuRef.current);\n    const hasFocusWithin = (_a = menuRef.current) == null ? void 0 : _a.contains(doc.activeElement);\n    const shouldRefocus = isOpen && !hasFocusWithin;\n    if (!shouldRefocus) return;\n    const node = (_b = descendants.item(focusedIndex)) == null ? void 0 : _b.node;\n    node == null ? void 0 : node.focus({\n      preventScroll: true\n    });\n  }, [isOpen, focusedIndex, descendants]);\n  const rafId = useRef(null);\n  return {\n    openAndFocusMenu,\n    openAndFocusFirstItem,\n    openAndFocusLastItem,\n    onTransitionEnd: refocus,\n    unstable__animationState: animationState,\n    descendants,\n    popper,\n    buttonId,\n    menuId,\n    forceUpdate: popper.forceUpdate,\n    orientation: \"vertical\",\n    isOpen,\n    onToggle,\n    onOpen,\n    onClose,\n    menuRef,\n    buttonRef,\n    focusedIndex,\n    closeOnSelect,\n    closeOnBlur,\n    autoSelect,\n    setFocusedIndex,\n    isLazy,\n    lazyBehavior,\n    initialFocusRef,\n    rafId\n  };\n}\nfunction useMenuButton(props = {}, externalRef = null) {\n  const menu = useMenuContext();\n  const {\n    onToggle,\n    popper,\n    openAndFocusFirstItem,\n    openAndFocusLastItem\n  } = menu;\n  const onKeyDown = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      Enter: openAndFocusFirstItem,\n      ArrowDown: openAndFocusFirstItem,\n      ArrowUp: openAndFocusLastItem\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n    }\n  }, [openAndFocusFirstItem, openAndFocusLastItem]);\n  return {\n    ...props,\n    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),\n    id: menu.buttonId,\n    \"data-active\": dataAttr(menu.isOpen),\n    \"aria-expanded\": menu.isOpen,\n    \"aria-haspopup\": \"menu\",\n    \"aria-controls\": menu.menuId,\n    onClick: callAllHandlers(props.onClick, onToggle),\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\nfunction isTargetMenuItem(target) {\n  var _a;\n  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute(\"role\")) == null ? void 0 : _a.startsWith(\"menuitem\"));\n}\nfunction useMenuList(props = {}, ref = null) {\n  const menu = useMenuContext();\n  if (!menu) {\n    throw new Error(`useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`);\n  }\n  const {\n    focusedIndex,\n    setFocusedIndex,\n    menuRef,\n    isOpen,\n    onClose,\n    menuId,\n    isLazy,\n    lazyBehavior,\n    unstable__animationState: animated\n  } = menu;\n  const descendants = useMenuDescendantsContext();\n  const createTypeaheadHandler = useShortcut({\n    preventDefault: event => event.key !== \" \" && isTargetMenuItem(event.target)\n  });\n  const onKeyDown = useCallback(event => {\n    if (!event.currentTarget.contains(event.target)) return;\n    const eventKey = event.key;\n    const keyMap = {\n      Tab: event2 => event2.preventDefault(),\n      Escape: onClose,\n      ArrowDown: () => {\n        const next = descendants.nextEnabled(focusedIndex);\n        if (next) setFocusedIndex(next.index);\n      },\n      ArrowUp: () => {\n        const prev = descendants.prevEnabled(focusedIndex);\n        if (prev) setFocusedIndex(prev.index);\n      }\n    };\n    const fn = keyMap[eventKey];\n    if (fn) {\n      event.preventDefault();\n      fn(event);\n      return;\n    }\n    const onTypeahead = createTypeaheadHandler(character => {\n      const nextItem = getNextItemFromSearch(descendants.values(), character, item => {\n        var _a, _b;\n        return (_b = (_a = item == null ? void 0 : item.node) == null ? void 0 : _a.textContent) != null ? _b : \"\";\n      }, descendants.item(focusedIndex));\n      if (nextItem) {\n        const index = descendants.indexOf(nextItem.node);\n        setFocusedIndex(index);\n      }\n    });\n    if (isTargetMenuItem(event.target)) {\n      onTypeahead(event);\n    }\n  }, [descendants, focusedIndex, createTypeaheadHandler, onClose, setFocusedIndex]);\n  const hasBeenOpened = useRef(false);\n  if (isOpen) {\n    hasBeenOpened.current = true;\n  }\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenOpened.current,\n    enabled: isLazy,\n    mode: lazyBehavior,\n    isSelected: animated.present\n  });\n  return {\n    ...props,\n    ref: mergeRefs(menuRef, ref),\n    children: shouldRenderChildren ? props.children : null,\n    tabIndex: -1,\n    role: \"menu\",\n    id: menuId,\n    style: {\n      ...props.style,\n      transformOrigin: \"var(--popper-transform-origin)\"\n    },\n    \"aria-orientation\": \"vertical\",\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\nfunction useMenuPositioner(props = {}) {\n  const {\n    popper,\n    isOpen\n  } = useMenuContext();\n  return popper.getPopperProps({\n    ...props,\n    style: {\n      visibility: isOpen ? \"visible\" : \"hidden\",\n      ...props.style\n    }\n  });\n}\nfunction useMenuItem(props = {}, externalRef = null) {\n  const {\n    onMouseEnter: onMouseEnterProp,\n    onMouseMove: onMouseMoveProp,\n    onMouseLeave: onMouseLeaveProp,\n    onClick: onClickProp,\n    onFocus: onFocusProp,\n    isDisabled,\n    isFocusable,\n    closeOnSelect,\n    type: typeProp,\n    ...htmlProps\n  } = props;\n  const menu = useMenuContext();\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    closeOnSelect: menuCloseOnSelect,\n    onClose,\n    menuRef,\n    isOpen,\n    menuId,\n    rafId\n  } = menu;\n  const ref = useRef(null);\n  const id = `${menuId}-menuitem-${useId()}`;\n  const {\n    index,\n    register\n  } = useMenuDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const onMouseEnter = useCallback(event => {\n    onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);\n    if (isDisabled) return;\n    setFocusedIndex(index);\n  }, [setFocusedIndex, index, isDisabled, onMouseEnterProp]);\n  const onMouseMove = useCallback(event => {\n    onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);\n    if (ref.current && !isActiveElement(ref.current)) {\n      onMouseEnter(event);\n    }\n  }, [onMouseEnter, onMouseMoveProp]);\n  const onMouseLeave = useCallback(event => {\n    onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);\n    if (isDisabled) return;\n    setFocusedIndex(-1);\n  }, [setFocusedIndex, isDisabled, onMouseLeaveProp]);\n  const onClick = useCallback(event => {\n    onClickProp == null ? void 0 : onClickProp(event);\n    if (!isTargetMenuItem(event.currentTarget)) return;\n    if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {\n      onClose();\n    }\n  }, [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]);\n  const onFocus = useCallback(event => {\n    onFocusProp == null ? void 0 : onFocusProp(event);\n    setFocusedIndex(index);\n  }, [setFocusedIndex, onFocusProp, index]);\n  const isFocused = index === focusedIndex;\n  const trulyDisabled = isDisabled && !isFocusable;\n  useUpdateEffect(() => {\n    if (!isOpen) return;\n    if (isFocused && !trulyDisabled && ref.current) {\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n      rafId.current = requestAnimationFrame(() => {\n        var _a;\n        (_a = ref.current) == null ? void 0 : _a.focus({\n          preventScroll: true\n        });\n        rafId.current = null;\n      });\n    } else if (menuRef.current && !isActiveElement(menuRef.current)) {\n      menuRef.current.focus({\n        preventScroll: true\n      });\n    }\n    return () => {\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current);\n      }\n    };\n  }, [isFocused, trulyDisabled, menuRef, isOpen]);\n  const clickableProps = useClickable({\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    ref: mergeRefs(register, ref, externalRef),\n    isDisabled,\n    isFocusable\n  });\n  return {\n    ...htmlProps,\n    ...clickableProps,\n    type: typeProp != null ? typeProp : clickableProps.type,\n    id,\n    role: \"menuitem\",\n    tabIndex: isFocused ? 0 : -1\n  };\n}\nfunction useMenuOption(props = {}, ref = null) {\n  const {\n    type = \"radio\",\n    isChecked,\n    ...rest\n  } = props;\n  const ownProps = useMenuItem(rest, ref);\n  return {\n    ...ownProps,\n    role: `menuitem${type}`,\n    \"aria-checked\": isChecked\n  };\n}\nfunction useMenuOptionGroup(props = {}) {\n  const {\n    children,\n    type = \"radio\",\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n    ...htmlProps\n  } = props;\n  const isRadio = type === \"radio\";\n  const fallback = isRadio ? \"\" : [];\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue != null ? defaultValue : fallback,\n    value: valueProp,\n    onChange: onChangeProp\n  });\n  const onChange = useCallback(selectedValue => {\n    if (type === \"radio\" && typeof value === \"string\") {\n      setValue(selectedValue);\n    }\n    if (type === \"checkbox\" && Array.isArray(value)) {\n      const nextValue = value.includes(selectedValue) ? value.filter(item => item !== selectedValue) : value.concat(selectedValue);\n      setValue(nextValue);\n    }\n  }, [value, setValue, type]);\n  const validChildren = getValidChildren(children);\n  const clones = validChildren.map(child => {\n    if (child.type.id !== \"MenuItemOption\") return child;\n    const onClick = event => {\n      var _a, _b;\n      onChange(child.props.value);\n      (_b = (_a = child.props).onClick) == null ? void 0 : _b.call(_a, event);\n    };\n    const isChecked = type === \"radio\" ? child.props.value === value : value.includes(child.props.value);\n    return cloneElement(child, {\n      type,\n      onClick,\n      isChecked\n    });\n  });\n  return {\n    ...htmlProps,\n    children: clones\n  };\n}\nfunction useMenuState() {\n  const {\n    isOpen,\n    onClose\n  } = useMenuContext();\n  return {\n    isOpen,\n    onClose\n  };\n}\nfunction isHTMLElement(el) {\n  var _a;\n  if (!isElement(el)) return false;\n  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;\n  return el instanceof win.HTMLElement;\n}\nfunction isElement(el) {\n  return el != null && typeof el == \"object\" && \"nodeType\" in el && el.nodeType === Node.ELEMENT_NODE;\n}\nexport { MenuDescendantsProvider, useMenuDescendantsContext, useMenuDescendants, useMenuDescendant, MenuProvider, useMenuContext, useMenu, useMenuButton, useMenuList, useMenuPositioner, useMenuItem, useMenuOption, useMenuOptionGroup, useMenuState };","map":{"version":3,"names":["useClickable","createDescendantContext","useFocusOnHide","usePopper","useDisclosure","useOutsideClick","useAnimationState","createContext","getValidChildren","useControllableState","useUpdateEffect","mergeRefs","dataAttr","callAllHandlers","lazyDisclosure","cloneElement","useCallback","useRef","useState","useId","useMemo","useEffect","MenuDescendantsProvider","useMenuDescendantsContext","useMenuDescendants","useMenuDescendant","MenuProvider","useMenuContext","strict","name","useIds","idProp","prefixes","reactId","id","map","prefix","getOwnerDocument","node","_a","ownerDocument","document","isActiveElement","element","doc","activeElement","useMenu","props","closeOnSelect","closeOnBlur","initialFocusRef","autoSelect","isLazy","isOpen","isOpenProp","defaultIsOpen","onClose","onCloseProp","onOpen","onOpenProp","placement","lazyBehavior","direction","computePositionOnMount","popperProps","menuRef","buttonRef","descendants","focusMenu","requestAnimationFrame","current","focus","preventScroll","focusFirstItem","id2","setTimeout","first","firstEnabled","setFocusedIndex","index","timeoutIds","add","focusLastItem","last","lastEnabled","onOpenInternal","onToggle","enabled","ref","handler","event","contains","target","popper","focusedIndex","focusRef","visible","shouldFocus","animationState","buttonId","menuId","openAndFocusMenu","Set","ids","forEach","clearTimeout","clear","openAndFocusFirstItem","openAndFocusLastItem","refocus","_b","hasFocusWithin","shouldRefocus","item","rafId","onTransitionEnd","unstable__animationState","forceUpdate","orientation","useMenuButton","externalRef","menu","onKeyDown","eventKey","key","keyMap","Enter","ArrowDown","ArrowUp","action","preventDefault","stopPropagation","referenceRef","onClick","isTargetMenuItem","isHTMLElement","getAttribute","startsWith","useMenuList","Error","animated","createTypeaheadHandler","useShortcut","currentTarget","Tab","event2","Escape","next","nextEnabled","prev","prevEnabled","fn","onTypeahead","character","nextItem","getNextItemFromSearch","values","textContent","indexOf","hasBeenOpened","shouldRenderChildren","wasSelected","mode","isSelected","present","children","tabIndex","role","style","transformOrigin","useMenuPositioner","getPopperProps","visibility","useMenuItem","onMouseEnter","onMouseEnterProp","onMouseMove","onMouseMoveProp","onMouseLeave","onMouseLeaveProp","onClickProp","onFocus","onFocusProp","isDisabled","isFocusable","type","typeProp","htmlProps","menuCloseOnSelect","register","disabled","isFocused","trulyDisabled","cancelAnimationFrame","clickableProps","useMenuOption","isChecked","rest","ownProps","useMenuOptionGroup","value","valueProp","defaultValue","onChange","onChangeProp","isRadio","fallback","setValue","selectedValue","Array","isArray","nextValue","includes","filter","concat","validChildren","clones","child","call","useMenuState","el","isElement","win","defaultView","window","HTMLElement","nodeType","Node","ELEMENT_NODE"],"sources":["C:\\Users\\ASUS\\OneDrive\\Documents\\Unit6_Cw\\eCommercebenevolent-boot\\musemind\\node_modules\\@chakra-ui\\menu\\src\\use-menu.ts"],"sourcesContent":["import { useClickable } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { useFocusOnHide } from \"@chakra-ui/react-use-focus-effect\"\nimport { usePopper, UsePopperProps } from \"@chakra-ui/popper\"\nimport {\n  useDisclosure,\n  UseDisclosureProps,\n} from \"@chakra-ui/react-use-disclosure\"\nimport { useOutsideClick } from \"@chakra-ui/react-use-outside-click\"\nimport { useAnimationState } from \"@chakra-ui/react-use-animation-state\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { dataAttr, callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\n\nimport React, {\n  cloneElement,\n  useCallback,\n  useRef,\n  useState,\n  useId,\n  useMemo,\n  useEffect,\n} from \"react\"\nimport { useShortcut } from \"./use-shortcut\"\nimport { getNextItemFromSearch } from \"./get-next-item-from-search\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  MenuDescendantsProvider,\n  useMenuDescendantsContext,\n  useMenuDescendants,\n  useMenuDescendant,\n] = createDescendantContext<HTMLElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track menu state and logic\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [MenuProvider, useMenuContext] = createContext<\n  Omit<UseMenuReturn, \"descendants\">\n>({\n  strict: false,\n  name: \"MenuContext\",\n})\n\n/* -------------------------------------------------------------------------------------------------\n * useMenu hook\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuProps\n  extends Omit<UsePopperProps, \"enabled\">,\n    UseDisclosureProps {\n  /**\n   * The `ref` of the element that should receive focus when the popover opens.\n   */\n  initialFocusRef?: React.RefObject<{ focus(): void }>\n  /**\n   * If `true`, the menu will close when a menu item is\n   * clicked\n   *\n   * @default true\n   */\n  closeOnSelect?: boolean\n  /**\n   * If `true`, the menu will close when you click outside\n   * the menu list\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean\n  /**\n   * If `true`, the first enabled menu item will receive focus and be selected\n   * when the menu opens.\n   *\n   * @default true\n   */\n  autoSelect?: boolean\n  /**\n   * Performance 🚀:\n   * If `true`, the MenuItem rendering will be deferred\n   * until the menu is open.\n   *\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance 🚀:\n   * The lazy behavior of menu's content when not visible.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The menu's content is always unmounted when not open.\n   * - \"keepMounted\": The menu's content initially unmounted,\n   * but stays mounted when menu is open.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * If `rtl`, proper placement positions will be flipped i.e. 'top-right' will\n   * become 'top-left' and vice-verse\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /*\n   * If `true`, the menu will be positioned when it mounts\n   * (even if it's not open).\n   *\n   * Note 🚨: We don't recommend using this in a menu/popover intensive UI or page\n   * as it might affect scrolling performance.\n   *\n   * @default false\n   */\n  computePositionOnMount?: boolean\n}\n\nfunction useIds(idProp?: string, ...prefixes: string[]) {\n  const reactId = useId()\n  const id = idProp || reactId\n  return useMemo(() => {\n    return prefixes.map((prefix) => `${prefix}-${id}`)\n  }, [id, prefixes])\n}\n\nfunction getOwnerDocument(node?: Element | null): Document {\n  return node?.ownerDocument ?? document\n}\n\nfunction isActiveElement(element: HTMLElement) {\n  const doc = getOwnerDocument(element)\n  return doc.activeElement === (element as HTMLElement)\n}\n\n/**\n * React Hook to manage a menu\n *\n * It provides the logic and will be used with react context\n * to propagate its return value to all children\n */\nexport function useMenu(props: UseMenuProps = {}) {\n  const {\n    id,\n    closeOnSelect = true,\n    closeOnBlur = true,\n    initialFocusRef,\n    autoSelect = true,\n    isLazy,\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    placement = \"bottom-start\",\n    lazyBehavior = \"unmount\",\n    direction,\n    computePositionOnMount = false,\n    ...popperProps\n  } = props\n  /**\n   * Prepare the reference to the menu and disclosure\n   */\n  const menuRef = useRef<HTMLDivElement>(null)\n  const buttonRef = useRef<HTMLButtonElement>(null)\n\n  /**\n   * Context to register all menu item nodes\n   */\n  const descendants = useMenuDescendants()\n\n  const focusMenu = useCallback(() => {\n    requestAnimationFrame(() => {\n      menuRef.current?.focus({ preventScroll: false })\n    })\n  }, [])\n\n  const focusFirstItem = useCallback(() => {\n    const id = setTimeout(() => {\n      if (initialFocusRef) {\n        initialFocusRef.current?.focus()\n      } else {\n        const first = descendants.firstEnabled()\n        if (first) setFocusedIndex(first.index)\n      }\n    })\n    timeoutIds.current.add(id)\n  }, [descendants, initialFocusRef])\n\n  const focusLastItem = useCallback(() => {\n    const id = setTimeout(() => {\n      const last = descendants.lastEnabled()\n      if (last) setFocusedIndex(last.index)\n    })\n    timeoutIds.current.add(id)\n  }, [descendants])\n\n  const onOpenInternal = useCallback(() => {\n    onOpenProp?.()\n    if (autoSelect) {\n      focusFirstItem()\n    } else {\n      focusMenu()\n    }\n  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp])\n\n  const { isOpen, onOpen, onClose, onToggle } = useDisclosure({\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onClose: onCloseProp,\n    onOpen: onOpenInternal,\n  })\n\n  useOutsideClick({\n    enabled: isOpen && closeOnBlur,\n    ref: menuRef,\n    handler: (event) => {\n      if (!buttonRef.current?.contains(event.target as HTMLElement)) {\n        onClose()\n      }\n    },\n  })\n\n  /**\n   * Add some popper.js for dynamic positioning\n   */\n  const popper: any = usePopper({\n    ...popperProps,\n    enabled: isOpen || computePositionOnMount,\n    placement,\n    direction,\n  })\n\n  const [focusedIndex, setFocusedIndex] = useState(-1)\n\n  /**\n   * Focus the button when we close the menu\n   */\n  useUpdateEffect(() => {\n    if (!isOpen) {\n      setFocusedIndex(-1)\n    }\n  }, [isOpen])\n\n  useFocusOnHide(menuRef, {\n    focusRef: buttonRef,\n    visible: isOpen,\n    shouldFocus: true,\n  })\n\n  const animationState = useAnimationState({ isOpen, ref: menuRef })\n\n  /**\n   * Generate unique ids for menu's list and button\n   */\n  const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`)\n\n  const openAndFocusMenu = useCallback(() => {\n    onOpen()\n    focusMenu()\n  }, [onOpen, focusMenu])\n\n  const timeoutIds = useRef<Set<any>>(new Set([]))\n\n  // clean up timeouts\n  useEffect(() => {\n    const ids = timeoutIds.current\n    return () => {\n      ids.forEach((id) => clearTimeout(id))\n      ids.clear()\n    }\n  }, [])\n\n  const openAndFocusFirstItem = useCallback(() => {\n    onOpen()\n    focusFirstItem()\n  }, [focusFirstItem, onOpen])\n\n  const openAndFocusLastItem = useCallback(() => {\n    onOpen()\n    focusLastItem()\n  }, [onOpen, focusLastItem])\n\n  const refocus = useCallback(() => {\n    const doc = getOwnerDocument(menuRef.current)\n    const hasFocusWithin = menuRef.current?.contains(doc.activeElement)\n    const shouldRefocus = isOpen && !hasFocusWithin\n\n    if (!shouldRefocus) return\n\n    const node = descendants.item(focusedIndex)?.node\n    node?.focus({ preventScroll: true })\n  }, [isOpen, focusedIndex, descendants])\n\n  /**\n   * Track the animation frame which is scheduled to focus\n   * a menu item, so it can be cancelled if another item\n   * is focused before the animation executes. This prevents\n   * infinite rerenders.\n   */\n  const rafId = useRef<number | null>(null)\n\n  return {\n    openAndFocusMenu,\n    openAndFocusFirstItem,\n    openAndFocusLastItem,\n    onTransitionEnd: refocus,\n    unstable__animationState: animationState,\n    descendants,\n    popper,\n    buttonId,\n    menuId,\n    forceUpdate: popper.forceUpdate,\n    orientation: \"vertical\",\n    isOpen,\n    onToggle,\n    onOpen,\n    onClose,\n    menuRef,\n    buttonRef,\n    focusedIndex,\n    closeOnSelect,\n    closeOnBlur,\n    autoSelect,\n    setFocusedIndex,\n    isLazy,\n    lazyBehavior,\n    initialFocusRef,\n    rafId,\n  }\n}\n\nexport interface UseMenuReturn extends ReturnType<typeof useMenu> {}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuButton hook\n * -----------------------------------------------------------------------------------------------*/\nexport interface UseMenuButtonProps\n  extends Omit<React.HTMLAttributes<Element>, \"color\"> {}\n\n/**\n * React Hook to manage a menu button.\n *\n * The assumption here is that the `useMenu` hook is used\n * in a component higher up the tree, and its return value\n * is passed as `context` to this hook.\n */\nexport function useMenuButton(\n  props: UseMenuButtonProps = {},\n  externalRef: React.Ref<any> = null,\n) {\n  const menu = useMenuContext()\n\n  const { onToggle, popper, openAndFocusFirstItem, openAndFocusLastItem } = menu\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        Enter: openAndFocusFirstItem,\n        ArrowDown: openAndFocusFirstItem,\n        ArrowUp: openAndFocusLastItem,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n      }\n    },\n    [openAndFocusFirstItem, openAndFocusLastItem],\n  )\n\n  return {\n    ...props,\n    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),\n    id: menu.buttonId,\n    \"data-active\": dataAttr(menu.isOpen),\n    \"aria-expanded\": menu.isOpen,\n    \"aria-haspopup\": \"menu\" as React.AriaAttributes[\"aria-haspopup\"],\n    \"aria-controls\": menu.menuId,\n    onClick: callAllHandlers(props.onClick, onToggle),\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nfunction isTargetMenuItem(target: EventTarget | null) {\n  // this will catch `menuitem`, `menuitemradio`, `menuitemcheckbox`\n  return (\n    isHTMLElement(target) &&\n    !!target?.getAttribute(\"role\")?.startsWith(\"menuitem\")\n  )\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuList\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuListProps\n  extends Omit<React.HTMLAttributes<Element>, \"color\"> {}\n\n/**\n * React Hook to manage a menu list.\n *\n * The assumption here is that the `useMenu` hook is used\n * in a component higher up the tree, and its return value\n * is passed as `context` to this hook.\n */\nexport function useMenuList(\n  props: UseMenuListProps = {},\n  ref: React.Ref<any> = null,\n): React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement> {\n  const menu = useMenuContext()\n\n  if (!menu) {\n    throw new Error(\n      `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`,\n    )\n  }\n\n  const {\n    focusedIndex,\n    setFocusedIndex,\n    menuRef,\n    isOpen,\n    onClose,\n    menuId,\n    isLazy,\n    lazyBehavior,\n    unstable__animationState: animated,\n  } = menu\n\n  const descendants = useMenuDescendantsContext()\n\n  /**\n   * Hook that creates a keydown event handler that listens\n   * to printable keyboard character press\n   */\n  const createTypeaheadHandler = useShortcut({\n    preventDefault: (event) =>\n      event.key !== \" \" && isTargetMenuItem(event.target),\n  })\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      // ignore events bubbles from portal children\n      if (!event.currentTarget.contains(event.target as Element)) return\n\n      const eventKey = event.key\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        Tab: (event) => event.preventDefault(),\n        Escape: onClose,\n        ArrowDown: () => {\n          const next = descendants.nextEnabled(focusedIndex)\n          if (next) setFocusedIndex(next.index)\n        },\n        ArrowUp: () => {\n          const prev = descendants.prevEnabled(focusedIndex)\n          if (prev) setFocusedIndex(prev.index)\n        },\n      }\n\n      const fn = keyMap[eventKey]\n\n      if (fn) {\n        event.preventDefault()\n        fn(event)\n        return\n      }\n\n      /**\n       * Typeahead: Based on current character pressed,\n       * find the next item to be selected\n       */\n      const onTypeahead = createTypeaheadHandler((character) => {\n        const nextItem = getNextItemFromSearch(\n          descendants.values(),\n          character,\n          (item) => item?.node?.textContent ?? \"\",\n          descendants.item(focusedIndex),\n        )\n        if (nextItem) {\n          const index = descendants.indexOf(nextItem.node)\n          setFocusedIndex(index)\n        }\n      })\n\n      if (isTargetMenuItem(event.target)) {\n        onTypeahead(event)\n      }\n    },\n    [\n      descendants,\n      focusedIndex,\n      createTypeaheadHandler,\n      onClose,\n      setFocusedIndex,\n    ],\n  )\n\n  const hasBeenOpened = useRef(false)\n  if (isOpen) {\n    hasBeenOpened.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenOpened.current,\n    enabled: isLazy,\n    mode: lazyBehavior,\n    isSelected: animated.present,\n  })\n\n  return {\n    ...props,\n    ref: mergeRefs(menuRef, ref),\n    children: shouldRenderChildren ? props.children : null,\n    tabIndex: -1,\n    role: \"menu\",\n    id: menuId,\n    style: {\n      ...props.style,\n      transformOrigin: \"var(--popper-transform-origin)\",\n    },\n    \"aria-orientation\": \"vertical\" as React.AriaAttributes[\"aria-orientation\"],\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuPosition: Composes usePopper to position the menu\n * -----------------------------------------------------------------------------------------------*/\n\nexport function useMenuPositioner(props: any = {}) {\n  const { popper, isOpen } = useMenuContext()\n  return popper.getPopperProps({\n    ...props,\n    style: {\n      visibility: isOpen ? \"visible\" : \"hidden\",\n      ...props.style,\n    },\n  })\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuItem: Hook for each menu item within the menu list.\n   We also use it in `useMenuItemOption`\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuItemProps\n  extends Omit<React.HTMLAttributes<Element>, \"color\" | \"disabled\"> {\n  /**\n   * If `true`, the menuitem will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and the menuitem is disabled, it'll\n   * remain keyboard-focusable\n   */\n  isFocusable?: boolean\n  /**\n   * Overrides the parent menu's `closeOnSelect` prop.\n   */\n  closeOnSelect?: boolean\n  /**\n   * The type of the menuitem.\n   */\n  type?: React.ButtonHTMLAttributes<HTMLButtonElement>[\"type\"]\n}\n\nexport function useMenuItem(\n  props: UseMenuItemProps = {},\n  externalRef: React.Ref<any> = null,\n) {\n  const {\n    onMouseEnter: onMouseEnterProp,\n    onMouseMove: onMouseMoveProp,\n    onMouseLeave: onMouseLeaveProp,\n    onClick: onClickProp,\n    onFocus: onFocusProp,\n    isDisabled,\n    isFocusable,\n    closeOnSelect,\n    type: typeProp,\n    ...htmlProps\n  } = props\n\n  const menu = useMenuContext()\n\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    closeOnSelect: menuCloseOnSelect,\n    onClose,\n    menuRef,\n    isOpen,\n    menuId,\n    rafId,\n  } = menu\n\n  const ref = useRef<HTMLDivElement>(null)\n  const id = `${menuId}-menuitem-${useId()}`\n\n  /**\n   * Register the menuitem's node into the domContext\n   */\n  const { index, register } = useMenuDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const onMouseEnter = useCallback(\n    (event: any) => {\n      onMouseEnterProp?.(event)\n      if (isDisabled) return\n      setFocusedIndex(index)\n    },\n    [setFocusedIndex, index, isDisabled, onMouseEnterProp],\n  )\n\n  const onMouseMove = useCallback(\n    (event: any) => {\n      onMouseMoveProp?.(event)\n      if (ref.current && !isActiveElement(ref.current)) {\n        onMouseEnter(event)\n      }\n    },\n    [onMouseEnter, onMouseMoveProp],\n  )\n\n  const onMouseLeave = useCallback(\n    (event: any) => {\n      onMouseLeaveProp?.(event)\n      if (isDisabled) return\n      setFocusedIndex(-1)\n    },\n    [setFocusedIndex, isDisabled, onMouseLeaveProp],\n  )\n\n  const onClick = useCallback(\n    (event: React.MouseEvent) => {\n      onClickProp?.(event)\n      if (!isTargetMenuItem(event.currentTarget)) return\n      /**\n       * Close menu and parent menus, allowing the MenuItem\n       * to override its parent menu's `closeOnSelect` prop.\n       */\n      if (closeOnSelect ?? menuCloseOnSelect) {\n        onClose()\n      }\n    },\n    [onClose, onClickProp, menuCloseOnSelect, closeOnSelect],\n  )\n\n  const onFocus = useCallback(\n    (event: React.FocusEvent) => {\n      onFocusProp?.(event)\n      setFocusedIndex(index)\n    },\n    [setFocusedIndex, onFocusProp, index],\n  )\n\n  const isFocused = index === focusedIndex\n\n  const trulyDisabled = isDisabled && !isFocusable\n\n  useUpdateEffect(() => {\n    if (!isOpen) return\n    if (isFocused && !trulyDisabled && ref.current) {\n      // Cancel any pending animations\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current)\n      }\n      rafId.current = requestAnimationFrame(() => {\n        ref.current?.focus({ preventScroll: true })\n        rafId.current = null\n      })\n    } else if (menuRef.current && !isActiveElement(menuRef.current)) {\n      menuRef.current.focus({ preventScroll: true })\n    }\n\n    return () => {\n      if (rafId.current) {\n        cancelAnimationFrame(rafId.current)\n      }\n    }\n  }, [isFocused, trulyDisabled, menuRef, isOpen])\n\n  const clickableProps = useClickable({\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    ref: mergeRefs(register, ref, externalRef),\n    isDisabled,\n    isFocusable,\n  })\n\n  return {\n    ...htmlProps,\n    ...clickableProps,\n    type: typeProp ?? (clickableProps as any).type,\n    id,\n    role: \"menuitem\",\n    tabIndex: isFocused ? 0 : -1,\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuOption: Composes useMenuItem to provide a selectable/checkable menu item\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuOptionOptions {\n  value?: string\n  isChecked?: boolean\n  type?: \"radio\" | \"checkbox\"\n  children?: React.ReactNode\n}\n\nexport interface UseMenuOptionProps\n  extends Omit<UseMenuItemProps, \"type\">,\n    UseMenuOptionOptions {}\n\nexport function useMenuOption(\n  props: UseMenuOptionProps = {},\n  ref: React.Ref<any> = null,\n) {\n  const { type = \"radio\", isChecked, ...rest } = props\n  const ownProps = useMenuItem(rest, ref)\n  return {\n    ...ownProps,\n    role: `menuitem${type}`,\n    \"aria-checked\": isChecked as React.AriaAttributes[\"aria-checked\"],\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * useMenuOptionGroup: Manages the state of multiple selectable menuitem or menu option\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseMenuOptionGroupProps {\n  value?: string | string[]\n  defaultValue?: string | string[]\n  type?: \"radio\" | \"checkbox\"\n  onChange?: (value: string | string[]) => void\n  children?: React.ReactNode\n}\n\nexport function useMenuOptionGroup(props: UseMenuOptionGroupProps = {}) {\n  const {\n    children,\n    type = \"radio\",\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n    ...htmlProps\n  } = props\n\n  const isRadio = type === \"radio\"\n\n  const fallback = isRadio ? \"\" : []\n\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue ?? fallback,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  const onChange = useCallback(\n    (selectedValue: string) => {\n      if (type === \"radio\" && typeof value === \"string\") {\n        setValue(selectedValue)\n      }\n\n      if (type === \"checkbox\" && Array.isArray(value)) {\n        const nextValue = value.includes(selectedValue)\n          ? value.filter((item) => item !== selectedValue)\n          : value.concat(selectedValue)\n\n        setValue(nextValue)\n      }\n    },\n    [value, setValue, type],\n  )\n\n  const validChildren = getValidChildren(children)\n\n  const clones = validChildren.map((child) => {\n    /**\n     * We've added an internal `id` to each `MenuItemOption`,\n     * let's use that for type-checking.\n     *\n     * We can't rely on displayName or the element's type since\n     * they can be changed by the user.\n     */\n    if ((child.type as any).id !== \"MenuItemOption\") return child\n\n    const onClick = (event: MouseEvent) => {\n      onChange(child.props.value)\n      child.props.onClick?.(event)\n    }\n\n    const isChecked =\n      type === \"radio\"\n        ? child.props.value === value\n        : value.includes(child.props.value)\n\n    return cloneElement(child, {\n      type,\n      onClick,\n      isChecked,\n    })\n  })\n\n  return {\n    ...htmlProps,\n    children: clones,\n  }\n}\n\nexport function useMenuState() {\n  const { isOpen, onClose } = useMenuContext()\n  return { isOpen, onClose }\n}\n\nfunction isHTMLElement(el: any): el is HTMLElement {\n  if (!isElement(el)) return false\n  const win = el.ownerDocument.defaultView ?? window\n  return el instanceof win.HTMLElement\n}\n\nfunction isElement(el: any): el is Element {\n  return (\n    el != null &&\n    typeof el == \"object\" &&\n    \"nodeType\" in el &&\n    el.nodeType === Node.ELEMENT_NODE\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}